This module handles the parsing, generation and manipulation of files in the [http://www.phyloxml.org/ phyloXML] format.

This code is not yet part of Biopython, and therefore the documentation has not been integrated into the Biopython Tutorial yet either.

==Availability==

The source code for this module currently lives on [[User%3AEricTalevich|Eric]]'s [http://github.com/etal/biopython/tree/phyloxml phyloxml branch] in GitHub. If you're interested in testing this code before it's been merged into Biopython, follow the instructions there to create your own fork, or just clone the phyloxml branch onto your machine.

Requirements:
* Biopython 1.50 or newer (older may work, but hasn't been tested)
* Python 2.4 or newer
* ElementTree module

The XML parser used in this module is ElementTree, new to the Python standard library in Python 2.5. To use this module in Python 2.4, you'll need to install a separate package that provides the ElementTree interface. Two exist:
* [http://codespeak.net/lxml/ lxml]
* [http://effbot.org/zone/element-index.htm elementtree] (or cElementTree)

The module attempts to import each of these compatible ElementTree implementations until it succeeds. The given XML file handle is then parsed incrementally to instantiate an object hierarchy containing the relevant phylogenetic information.

==About the format==

A complete phyloXML document has a root node with the tag "phyloxml". Directly under the root is a sequence of "phylogeny" elements (phylogenetic trees), possibly followed by other arbitrary data not included in the phyloXML spec. The main structural element of these phylogenetic trees is the Clade: a tree has a clade attribute, along with other attributes, and each clade contains a series of clades (and other attributes), recursively.

The child nodes and attributes of each XML node are mapped onto classes in the PhyloXML.Tree module, keeping the names the same where possible; the XML document structure is closely mirrored in the Phyloxml objects produced by Bio.TreeIO.PhyloXMLIO.read().

==I/O functions==

To start working with phyloXML files, use the [[TreeIO]] package with 'phyloxml' as the format argument:

<source lang=python>
from Bio import TreeIO
tree = TreeIO.read('some-trees.xml', 'phyloxml')
# ValueError: There are multiple trees in this file; use parse() instead.
trees = TreeIO.parse('some-trees.xml', 'phyloxml')
TreeIO.write(trees.next(), 'first-tree.xml', 'phyloxml')
TreeIO.write(trees, 'rest-trees.xml', 'phyloxml')
</source>

These functions work with Phylogeny objects (derived from BaseTree.Tree) from the Bio.Tree.PhyloXML module. This standard API is enough for most use cases.

===PhyloXMLIO===

Within the Bio.TreeIO module, the I/O functions for the phyloXML format are implemented in the PhyloXMLIO sub-module. For access to some additional functionality beyond the basic TreeIO API, or to skip specifying the 'phyloxml' format argument each time, this can be imported directly:

<source lang=python>
from Bio.TreeIO import PhyloXMLIO
</source>

The read() function returns a single Bio.Tree.PhyloXML.Phyloxml object representing the entire file's data. The phylogenetic trees are in the "phylogenies" attribute, and any other arbitrary data is stored in "other".

<source lang=python>
>>> phx = TreeIO.read('phyloxml_examples.xml', 'phyloxml')
>>> print phx
Phyloxml
>>> len(phx.phylogenies)
13
>>> len(phx.other)
1
>>> print phx.other
[Other(tag='alignment', namespace='http://example.org/align')]
>>> print phx.other[0].children
[Other(tag='seq', namespace='http://www.phyloxml.org', value='acgtcgcggcccgtggaagtcctctcct'),
Other(tag='seq', namespace='http://www.phyloxml.org', value='aggtcgcggcctgtggaagtcctctcct'),
Other(tag='seq', namespace='http://www.phyloxml.org', value='taaatcgc--cccgtgg-agtccc-cct')]
</source>

If you aren't interested in the "other" data, you can use parse() to iteratively construct just the phylogenetic trees contained in the file -- this is exactly the same as calling TreeIO.parse() with the 'phyloxml' format argument.

PhyloXMLIO.write() is similar to TreeIO.write(), but also accepts a Phyloxml object (the result of read() or to_phyloxml()) to serialize. Optionally, an encoding other than UTF-8 can be specified.

<source lang=python>
>>> phx = TreeIO.read('phyloxml_examples.xml', 'phyloxml')
>>> print phx.other
[Other(tag='alignment', namespace='http://example.org/align')]
>>> phx.other = []
>>> PhyloXML.write(phx, 'ex_no_other.xml', 'phyloxml', encoding='ascii')
>>> phx_no = TreeIO.read('ex_no_other.xml', 'phyloxml')
>>> phx_no.other
[]
</source>

PhyloXMLIO also contains a utility called dump_tags() for printing all of the XML tags as they are encountered in a phyloXML file. This can be helpful for debugging, or used along with grep or sort -u on the command line to obtain a list of the tags a phyloXML file contains.

<pre>
>>> PhyloXMLIO.dump_tags('phyloxml_examples.xml')
{http://www.phyloxml.org}phyloxml
{http://www.phyloxml.org}phylogeny
{http://www.phyloxml.org}name
{http://www.phyloxml.org}description
{http://www.phyloxml.org}clade
...
</pre>


==Using PhyloXML objects==

Standard Python syntactic sugar is supported wherever it's reasonable.

* str() makes a string of the object's class name and an identifier, suitable for labeling a node in generated graph
* repr() makes a string resembling the object constructor call, such that <tt>eval(repr(obj))</tt> will return <tt>obj</tt> for simpler PhyloXML objects, and at least partially rebuild more complex objects.
* iter() is supported by Phyloxml and Clade objects, iterating over the contained phylogenies and sub-clades, respectively
* len() is supported by the same objects that support iteration, with expected results

Clade objects also support slicing and multiple indexing:
<source lang=python>
tree = TreeIO.parse('example.xml', 'phyloxml').next()
assert tree.clade[0] == tree.clade.clades[0]
assert tree.clade[0,1] == tree.clade.clades[0].clades[1]
</source>

Since valid Phylogeny objects always have a single clade attribute, this style of indexing is a handy way to reach specific nodes buried deep in the tree if you happen to know exactly where they are.

A couple of methods allow converting a selection to a new PhyloXML object: Phylogeny.to_phyloxml() and Clade.to_phylogeny(). A few use cases:
* Parse a phyloXML containing multiple phylogenetic trees. Check each tree sequentially, and upon finding a tree with the desired characteristic, isolate it as a new PhyloXML object.
<source lang=python>
for tree in TreeIO.parse('example.xml', 'phyloxml'):
    if tree.name == 'monitor lizards':
        return tree.to_phyloxml()
</source>
* Extract a specific sub-clade and make it a separate phylogeny (and probably a new phyloXML file).
<source lang=python>
tree = TreeIO.parse('example.xml', 'phyloxml').next()
best = None
for clade in tree.clade:
    if (clade.confidences[0].type == 'bootstrap'
            and (best is None
                or clade.confidences[0].value > best.confidences[0].value)):
        best = clade
phyloxml = best.to_phylogeny(rooted=True).to_phyloxml()
TreeIO.write(phyloxml, 'example_best.xml', 'phyloxml')
</source>

==Integrating with the rest of Biopython==

The classes used by this module inherit from the [[Tree]] module's generalized BaseTree classes, and therefore have access to the methods defined on those base classes. Since the phyloXML specification is very detailed, these subclasses are kept in a separate module, Bio.Tree.PhyloXML, and offer additional methods for converting between phyloXML and standard Biopython types.

The PhyloXML.Sequence class contains methods for converting to and from Biopython [[SeqRecord]] objects -- to_seqrecord() and from_seqrecord(). This includes the molecular sequence (mol_seq) as a [[Seq]] object, and the protein domain architecture as list of [[SeqFeature]] objects. Likewise, PhyloXML.ProteinDomain objects have a to_seqfeature() method.

==Performance==

This parser is meant to be able to handle large files, meaning several thousand external nodes. (Benchmarks of relevant XML parsers for Python are [http://effbot.org/zone/celementtree.htm#benchmarks here].) It has been tested with files of this size; for example, the complete NCBI taxonomy parses in about 100 seconds and consumes about 1.3 GB of memory. Provided enough memory is available on the system, the writer can also rebuild phyloXML files of this size.

The read() and parse() functions process a complete file in about the same amount of CPU time. Most of the underlying code is the same, and the majority of the time is spent building Clade objects (the most common node type). For small files (smaller than ncbi_taxonomy_mollusca.xml), the write() function serializes the complete object back to an equivalent file slightly slower than the corresponding read() call; for very large files, write() finishes faster than read().

Here are some times on a 2.00GHz Intel Xeon E5405 processor (only 1 CPU core used) with 7.7GB memory, running the standard Python 2.6.2 on Ubuntu 9.04, choosing the best of 3 runs for each function:

{| border="1" padding="0"
|-
!File !! Ext. Nodes !! Size (uncompressed) !! Read (s) !! Parse (s) !! Write (s)
|-
|apaf.xml
|
|38 KB
|0.01
|0.01
|0.02
|-
|bcl_2.xml
|
|105 KB
|0.03
|0.02
|0.04
|-
|ncbi_taxonomy_mollusca.xml
|5632
|1.5 MB
|0.65
|0.62
|0.67
|-
|tol_life_on_earth_1.xml
|57124
|46 MB
|10.55
|10.90
|9.26
|-
|ncbi_taxonomy_metazoa.xml
|73907
|33 MB
|15.99
|16.01
|8.98
|-
|ncbi_taxonomy.xml
|263691
|31 MB (unindented)
|97.61
|97.87
|26.99
|}

On 32-bit architectures, [http://psyco.sourceforge.net/ psyco] might improve these times significantly, at the risk of increasing memory usage. (I haven't tested it.) For comparison, the Java-based parser used in Forester and ATV (see below) reads the same files about 3-5 times as quickly, or up to 15x for the largest file.

For Python 2.4, performance depends on which ElementTree implementation is used. Using the original pure-Python elementtree, reading/parsing takes about twice as much time for all file sizes, but writing is only significantly slower for very large files.

==Summer of Code project==

This module is being developed by [[User%3AEricTalevich|Eric Talevich]] as a project for Google Summer of Code 2009, with NESCent as the mentoring organization and Brad Chapman as the primary mentor.

Main SoC project page: [https://www.nescent.org/wg_phyloinformatics/PhyloSoC:Biopython_support_for_parsing_and_writing_phyloXML PhyloSoC:Biopython support for parsing and writing phyloXML]

==Related software==

[http://monochrome-effect.net/ Christian Zmasek], one of the authors of the phyloXML specification, has released some software that uses this format:

* [http://www.phylosoft.org/forester/ Forester] -- a collection of Java and Ruby libraries for working with phylogenetic data
* [http://www.phylosoft.org/archaeopteryx/ Archaopteryx] -- Java application for the visualization of annotated phylogenetic trees (also available in applet form)

Another list is maintained at [http://www.phylosoft.org/ phylosoft.org].