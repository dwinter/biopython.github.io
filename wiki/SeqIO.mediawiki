This page is for the documentation for a new Sequence Input/Output interface for BioPython.

Some code has now been checked in under Bio.SeqIO, other bits are available on [http://bugzilla.open-bio.org/show_bug.cgi?id=2059 Bug 2059].  Details are currently being discussed on the [http://biopython.org/wiki/Mailing_lists Development mailing list].

We would like to recreate the simplicity of [http://www.bioperl.org/wiki/HOWTO:SeqIO BioPerl's SeqIO], and in the long term its [http://www.bioperl.org/wiki/Sequence_formats impressive list of supported file formats].

As currently implemented, the BioPython code covers multiple alignment file formats as well.  Alignment specific handling may be required in the future should the BioPython alignment object become capable of holding more than just sequence level annotation.  See also BioPerl's list of [http://www.bioperl.org/wiki/Multiple_alignment_formats multiple alignment formats].

Peter

== Helper Functions ==

There are four helper functions which all take a filename, and optional format.  Each sequence is returned as a SeqRecord object.

* File2SequenceIterator, returns a iterator (low memory, forward access only)
* File2SequenceList, returns a list of sequences (high memory, random access)
* File2SequenceDict, returns a dictionary of sequences (high memory, random access by ID)
* File2Alignment, returns an alignment object (for use with multiple sequence alignment file formats)

For sequential file formats (like Fasta, GenBank, EMBL etc) the file can be read record by record, and thus the iterator interface can save a significant amount of memory (RAM) which allows you to deal with very large files.

For interlaced file formats (like Clustal/Clustalw or annotated Stockholm files) the entire file must be read in one go.  You may not save much memory by using the SequenceIterator in this case, but it is provided so that you shouldn't need to re-write your code if you change the input file format.

For writing records to a file there is a single helper function:

* Sequences2File, takes records and filename

For sequential files, it may be possible to write the records to file one by one.  You will have to use the appropriate format writer object directly for that.

== Examples using the Helper Functions ==

To do...

== SequenceIterator ==

...

== Adding new file formats ==

To add support for reading a new file format, you just have to implement an iterator that expects a just file handle and returns SeqRecord objects.  You may do this using:

* A generator function (using the yeild keyword)
* Your own iterator class (consider subclassing something from Bio.SeqIO.Interfaces for this)
* Build a list of SeqRecords and then turn it into a list iterator using the iter() function.

You may accept additional ''optional'' arguments (alphabet for example).

The the new format must be added to the relevant mappings in Bio/SeqIO/__iter__.py plus any standard file extensions.