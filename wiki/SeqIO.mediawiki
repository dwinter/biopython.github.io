The page describes Bio.SeqIO, a new Sequence Input/Output interface for BioPython.

Some code has now been checked into CVS, and other bits are available on [http://bugzilla.open-bio.org/show_bug.cgi?id=2059 Bug 2059].  Details are currently being discussed on the [http://biopython.org/wiki/Mailing_lists Development mailing list].

If all goes well, the code will be available in the next release, probably BioPython 1.43.

== Aims ==

We would like to recreate the simplicity of [http://www.bioperl.org/wiki/HOWTO:SeqIO BioPerl's SeqIO], and in the long term its [http://www.bioperl.org/wiki/Sequence_formats impressive list of supported file formats].

As currently implemented, the BioPython code covers multiple alignment file formats as well.  Alignment specific handling may be required in the future should the BioPython alignment object become capable of holding more than just sequence level annotation.  See also BioPerl's list of [http://www.bioperl.org/wiki/Multiple_alignment_formats multiple alignment formats].

Bio.SeqIO provides a simple uniform interface to assorted file formats, but will ''only'' return sequences as SeqRecord objects.  

In some cases, this does lead to some apparent duplication.  For example, Bio.SeqIO and Bio.Nexus will both read sequences from Nexus files.  However, Bio.Nexus can also do much more, for example reading any phylogenetic trees in a Nexus file.

Peter

== File Formats ==

{| border="1" cellpadding="4" cellspacing="0"
|+ Table 1: Bio.SeqIO supported file formats
|-
! Format name
! Reads
! Writes
! Notes
|-
| fasta   
| Yes
| Yes
|
|-  
| genbank 
| Yes
| No
| Uses Bio.GenBank
|-
| clustal
| Yes
| Yes
| Currently uses Bio.Clustalw for writing
|-
| nexus
| Yes
| No
| Also known as PUAP format.  Uses Bio.Nexus
|-
| phylip
| Yes
| Yes
| Truncates names at 10 characters.
|-
| stockholm
| Yes
| Yes
| Also known as PFAM format.
|-
|}

At the moment (unlike BioPerl) sequence alignment file formats are treated much like any other sequence file. However, when writing your data to an alignment file format, note all the (gapped) sequences must be the same length.

== Helper Functions ==

There are four helper functions which all take a filename, and optional format.  Each sequence is returned as a SeqRecord object.

* '''File2SequenceIterator''', returns a iterator (low memory, forward access only)
* '''File2SequenceList''', returns a list of sequences (high memory, random access)
* '''File2SequenceDict''', returns a dictionary of sequences (high memory, random access by ID)
* '''File2Alignment''', returns an alignment object (for use with multiple sequence alignment file formats)

For sequential file formats (like Fasta, GenBank, EMBL etc) the file can be read record by record, and thus the iterator interface can save a significant amount of memory (RAM) which allows you to deal with very large files.

For interlaced file formats (like Clustal/Clustalw or annotated Stockholm files) BioPython has to read the entire file in one go.  This means using'File2SequenceIterator rather than File2SequenceList will not actually save you much memory.

The function File2Alignment is intended for use with alignment file formats (like Clustal, Stockholm, Nexus) but can be used with any sequence file provided that all the sequences are the same length (e.g. an alignment stored in fasta format).

For writing records to a file there is a single helper function:

* '''Sequences2File''', takes records and filename

Note that if you are writing to an alignment file format, all your sequences must be the same length.

For sequential files (like fasta), it may be possible to write the records to file one by one.  You will have to use the appropriate format writer object directly for that, or supply your records as an iterator.

== Examples using the Helper Functions ==

Suppose you have a fasta file, "example.fasta", which you wish to load.  The simplest way to load this would be as follows:

 from Bio.SeqIO import File2SequenceIterator
 for record in File2SequenceIterator("example.fasta") :
     print record.id
     print record.seq

In the above example, BioPython is able to guess the file format from the extension.  Just to be on the safe side, you can (and probably should) explicitly specify the file format:

 from Bio.SeqIO import File2SequenceIterator
 for record in File2SequenceIterator("example.fasta", format="fasta") :
     print record.id
     print record.seq

Or,

 from Bio.SeqIO import File2SequenceIterator
 for record in File2SequenceIterator("example.gbk", format="genbank") :
     print record.id
     print record.seq

Specifying the file format is a good habit to get into.  In some cases you may not have a recognised file extension - perhaps you have your data in fasta format but in a file called "my_seqs.txt".  To read this file, you would ''have'' to tell BioPython the file format:

 from Bio.SeqIO import File2SequenceIterator
 for record in File2SequenceIterator("my_seqs.txt", format="fasta") :
     print record.id
     print record.seq

== Adding new file formats ==

This section of the document is aimed at developers who want to contribute support for a new file format to BioPython.

'''Note:''' The details are still subject to change

To add support for reading a new file format, you must implement an iterator that expects a just file handle and returns SeqRecord objects.  You may do this using:

* An iterator class subclassing something from Bio.SeqIO.Interfaces
* A generator function (using the yield keyword; suitable for simple formats)
* An ordinary function which returns an iterator.  For example, you could build a list of SeqRecords and then turn it into an iterator using the iter() function.

You may accept additional ''optional'' arguments (an alphabet for example).  However there ''must'' be one and only one required argument (the input file handle).

What you use as the SeqRecord's id, name and description will depend on the file format.  Ideally you would use the accesion number for the id.

When storing any annotations in the record's annotations dictionary follow the defacto standard laid down by the GenBank parser... I should try and document this more.

To add support for writing a new file format you should write a sub class of one of the writer objects in Bio.SeqIO.Interfaces

Then, the new format must be added to the relevant mappings in Bio/SeqIO/__iter__.py so that the helper functions are aware of it.  In addtion, if there are standard non-ambiguous file extensions used by this file format, they should also be defined in Bio/SeqIO/__iter__.py