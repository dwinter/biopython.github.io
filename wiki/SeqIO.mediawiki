This page describes Bio.SeqIO, a new Sequence Input/Output interface for BioPython.

Some code has now been checked into [http://cvs.biopython.org/cgi-bin/viewcvs/viewcvs.cgi/biopython/Bio/SeqIO/?cvsroot=biopython#dirlist CVS], and other bits are available on [http://bugzilla.open-bio.org/show_bug.cgi?id=2059 Bug 2059].  Details are currently being discussed on the [http://biopython.org/wiki/Mailing_lists Development mailing list].

If all goes well, the code will be available in the next release, probably BioPython 1.43.

== Aims ==

We would like to recreate the simplicity of [http://www.bioperl.org/wiki/HOWTO:SeqIO BioPerl's SeqIO], and in the long term its impressive list of supported [http://www.bioperl.org/wiki/Sequence_formats sequence file formats] and [http://www.bioperl.org/wiki/Multiple_alignment_formats multiple alignment formats].

Bio.SeqIO provides a simple uniform interface to assorted file formats (including multiple sequence alignments), but will ''only'' return sequences as [[SeqRecord]] objects (which can be turned into alignment objects).  

Note that the inclusion of Bio.SeqIO does lead to some duplication or choice in how to deal with some file formats.  For example, Bio.SeqIO and Bio.Nexus will both read sequences from Nexus files - but Bio.Nexus can also do much more, for example reading any phylogenetic trees in a Nexus file.

My vision is that for manipulating sequence data you should try Bio.SeqIO as your first choice.  Unless you have some very specific requirements, I hope this should suffice.

Peter

== File Formats ==

This table lists the file formats that Bio.SeqIO can read and write.  The format name is a simple lowercase string. Where possible we use the same name as [http://www.bioperl.org/wiki/HOWTO:SeqIO#Formats BioPerl's SeqIO] and [http://emboss.sourceforge.net/docs/themes/SequenceFormats.html EMBOSS].

{| border="1" cellpadding="4" cellspacing="0"
|+ Table 1: Bio.SeqIO supported file formats
|-
! Format name
! Reads
! Writes
! Notes
|-
| fasta   
| Yes
| Yes
|
|-  
| genbank 
| Yes
| No
| Uses Bio.GenBank
|-  
| embl
| Yes
| No
| New! Also uses Bio.GenBank
|-
| clustal
| Yes
| Yes
| Currently uses Bio.Clustalw for writing
|-
| swiss
| Yes
| No
| Swiss-Prot aka UniProt. Uses Bio.SwissProt
|-
| nexus
| Yes
| No
| Also known as PAUP format.  Uses Bio.Nexus
|-
| phylip
| Yes
| Yes
| Truncates names at 10 characters.
|-
| stockholm
| Yes
| Yes
| Also known as PFAM format.
|-
|}

At the moment (unlike BioPerl) sequence alignment file formats are treated much like any other sequence file. You can convert a set of records from any file format into an alignment - provided they are all the same length.

Note that when writing your data to an alignment file format, all the (gapped) sequences should be the same length.

== Sequence Input ==

The main function is '''SequenceIterator''' which takes a file handle and format name, and returns a [[SeqRecord]] iterator.  This lets you do things like:

<source lang=python>
from Bio.SeqIO import SequenceIterator
handle = open("example.fasta", "rU")
for record in SequenceIterator(handle, "fasta") :
    print record.id
</source>

If you had a different type of file, for example a SwissProt file, the only difference is you specify "swiss" instead of "fasta":

<source lang=python>
from Bio.SeqIO import SequenceIterator
handle = open("P18522.txt", "rU")
for record in SequenceIterator(handle, "swiss") :
    print record.id
</source>

Iterators are great for when you only need the records one by one, in the order found in the file.  For some tasks you may need to have random access to the records in any order.  In this situation, use the built in python '''list''' function to turn the iterator into a list:

<source lang=python>
from Bio.SeqIO import SequenceIterator
handle = open("example.fasta", "rU")
records = list(SequenceIterator(handle, "fasta"))
print records[0].id  #first record
print records[-1].id #last record
</source>

Another common task is to index your records by some identifier.  For this we have a function '''SequencesToDict''' to turn a SeqRecord iterator (or list) into a dictionary:

<source lang=python>
from Bio.SeqIO import SequenceIterator, SequencesToDict
handle = open("example.fasta", "rU")
record_dict = SequencesToDict(SequenceIterator(handle, "fasta"))
print record_dict["gi:12345678"] #use any record ID
</source>

The function '''SequencesToDict''' will use the record ID as the dictionary key by default, but you can specify any mapping you like with its optional argument.

Finally the function '''SequencesToAlignment''' can be used to turn a SeqRecord iterator (or list) into an alignment object - provided all the sequences are the same length:

<source lang=python>
from Bio.SeqIO import SequenceIterator, SequencesToAlignment
handle = open("example.aln", "rU")
alignment = SequencesToAlignment(SequenceIterator(handle, "clustal"))
for column in range(alignment.get_alignment_length()) :
    print  "%s column %i" % (alignment.get_column(column),column)
</source>

Note that you do have to specify the file format explicitly, unlike in BioPerl's SeqIO which will try and guess using the file name extension and/or the file contents.

== Sequence Output ==

For writing records to a file use the function '''WriteSequences''', which takes a SeqRecord iterator (or list), output handle and format string:

<source lang=python>
from Bio.SeqIO import WriteSequences
sequences = ... # add code here
output_handle = open("example.fasta", "w")
WriteSequences(sequences, output_handle, "fasta")
output_handle.close()
</source>

There are more examples in the following section on converting between file formats.

Note that if you are writing to an alignment file format, all your sequences must be the same length.

If you supply the sequences as a '''SeqRecord''' iterator, then for sequential file formats like Fasta or GenBank, the records can be written one by one. Because only one record is created at a time, very little memory is required.  See the example below filtering a set of records.

On the other hand, for interlaced or non-sequential file formats like Clustal, the '''WriteSequences''' function will be forced to automatically convert an iterator into a list.  This will destroy any potential memory saving from using an generator/iterator approach.

== File Format Conversion ==

Suppose you have a GenBank file which you want to turn into a Fasta file.  For example, lets consider the file 'cor6_6.gb' (included in the BioPython unit tests under the GenBank directory) which contains six records.

You could read the file like this:

<source lang=python>
from Bio.SeqIO import SequenceIterator
input_handle = open("cor6_6.gb", "rU")
for record in SequenceIterator(input_handle, "genbank") :
    print record
</source>

Instead, let's pass the SeqRecord iterator directly to the '''WriteSequences''' function:

<source lang=python>
from Bio.SeqIO import SequenceIterator, WriteSequences

input_handle = open("cor6_6.gb", "rU")
sequences = SequenceIterator(input_handle, "genbank")

output_handle = open("cor6_6.fasta", "w")
WriteSequences(sequences, output_handle, "fasta")
output_handle.close()
</source>

Or more concisely, just:

<source lang=python>
from Bio.SeqIO import SequenceIterator, WriteSequences
WriteSequences(SequenceIterator(open("cor6_6.gb", "rU"), "genbank"), \
               open("cor6_6.fasta", "w"), "fasta")
</source>

In this example the GenBank file started like this:

 LOCUS       ATCOR66M      513 bp    mRNA            PLN       02-MAR-1992
 DEFINITION  A.thaliana cor6.6 mRNA.
 ACCESSION   X55053
 VERSION     X55053.1  GI:16229
 ...

The resulting Fasta file looks like this:

 >X55053.1 A.thaliana cor6.6 mRNA.
 AACAAAACACACATCAAAAACGATTTTACAAGAAAAAAATA...
 ...

By changing the format strings, that code could be used to convert between any supported file formats.

== Input/Output Example - Filtering by sequence length ==

While you may simply want to convert a file (as shown above), a more realistic example is to manipulate or filter the data in some way.

For example, let's save all the "short" sequences of less than 300 nucleotides to a Fasta file:

<source lang=python>
from Bio.SeqIO import SequenceIterator, WriteSequences

short_sequences = [] # Setup an empty list
for record in SequenceIterator(open("cor6_6.gb", "rU"), "genbank")
    if len(record.seq) < 300 :
        # Add this record to our list
        short_sequences.append(record)

print "Found %i short sequences" % len(short_sequences)

output_handle = open("short_seqs.fasta", "w")
WriteSequences(short_sequences, output_handle, "fasta")
output_handle.close()
</source>

If you know about '''list comprehensions''' which were introduced in Python 2.0, then you could have written the above example like this instead:

<source lang=python>
from Bio.SeqIO import SequenceIterator, WriteSequences

input_seq_iterator = SequenceIterator(open("cor6_6.gb", "rU"), "genbank")

#Build a list of short sequences:
short_sequences = [record for record in input_seq_iterator \
                   if len(record.seq) < 300]

print "Found %i short sequences" % len(short_sequences)

output_handle = open("short_seqs.fasta", "w")
WriteSequences(short_sequences, output_handle, "fasta")
output_handle.close()
</source>

I'm not convinced this is actually any easier to understand, but it is shorter.

However, if you are using Python 2.4 or later, and you are dealing with very large files with thousands of records, you could benefit from using a '''generator expression''' instead.  This avoids creating the entire list of desired records in memory:

<source lang=python>
from Bio.SeqIO import SequenceIterator, WriteSequences

input_seq_iterator = SequenceIterator(open("cor6_6.gb", "rU"), "genbank")
short_seq_iterator = (record for record in input_seq_iterator \
                      if len(record.seq) < 300)

output_handle = open("short_seqs.fasta", "w")
WriteSequences(short_seq_iterator, output_handle, "fasta")
output_handle.close()
</source>

Remember that for sequential file formats like Fasta or GenBank, the '''WriteSequences''' will accept a '''SeqRecord''' iterator.  The advantage of the code above is that only one record will be in memory at any one time.

However, as explained in the output section, for non-sequential file formats like Clustal the '''WriteSequences''' is forced to automatically turn the iterator into a list, so this advantage is lost.

If this is all confusing, ''don't panic'' and just ignore the fancy stuff.  For moderately sized datasets having too many records in memory at once (e.g. in lists) is probably not going to be a problem.

== Adding new file formats ==

This section of the document is aimed at developers who want to contribute support for a new file format to BioPython.

'''Note:''' The details are still subject to change

To add support for reading a new file format, you must implement an iterator that expects a just file handle and returns SeqRecord objects.  You may do this using:

* An iterator class subclassing something from Bio.SeqIO.Interfaces
* A generator function (using the yield keyword; suitable for simple formats)
* An ordinary function which returns an iterator.  For example, you could build a list of SeqRecords and then turn it into an iterator using the iter() function.

You may accept additional ''optional'' arguments (an alphabet for example).  However there ''must'' be one and only one required argument (the input file handle).

What you use as the SeqRecord's id, name and description will depend on the file format.  Ideally you would use the accesion number for the id.  This id should also be unique for each record (unless the records in the file are in themselves ambiguous).

When storing any annotations in the record's annotations dictionary follow the defacto standard laid down by the GenBank parser... I should try and document this more.

To add support for writing a new file format you should write a sub class of one of the writer objects in Bio.SeqIO.Interfaces

Then, the new format must be added to the relevant mappings in Bio/SeqIO/__init__.py so that the '''SequenceIterator''' and '''WriteSequences''' functions are aware of it.  In addition, if there are standard non-ambiguous file extensions used by this file format, they should also be defined in Bio/SeqIO/__init__.py

== Possible additional formats ==

There are existing parsers in BioPython for the following file formats, which could be integrated into Bio.SeqIO if appropriate.

=== NBRF / PIR format ===

Bio.NBRF has a Martel parser for this file format, which is similar to the FASTA format.  It would need addition work to return SeqRecords.  It might be easier to extend to reuse the Bio.SeqIO fasta code instead.

http://www.psc.edu/general/software/packages/seq-intro/nbrffile.html

=== MASE alignment format ===

Bio.IntelliGenetics seems to use Martel parse MASE format files into its own record object.  It could be extended to return SeqRecord objects.  See:

http://pbil.univ-lyon1.fr/help/formats.html

=== MEME format ===

Bio.MEME has a parser for this file format, which at first glance looks like it could be treated like an alignment format.

http://meme.sdsc.edu

=== BLAST results ===

Pairwise alignments from the BLAST suite could be turned into two SeqRecord objects with gapped sequences.  Is this useful?

=== COMPASS pairwise alignment format ===

Bio.Compass can parse the pairwise alignments from COMPASS.  The output is similar to BLAST in many ways.  Again, is getting the results as SeqRecord objects useful?

== Bio.SeqIO.FASTA ==

There is some "old" code living in the module Bio.SeqIO.FASTA such as FastaReader.  My plan is to mark this as depreciated once the "new" SeqIO code (described above) is stable.